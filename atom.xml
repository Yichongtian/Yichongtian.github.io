<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Yichongtian.github.io</id>
    <title>Onion|个人博客</title>
    <updated>2023-05-04T14:21:45.672Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Yichongtian.github.io"/>
    <link rel="self" href="https://Yichongtian.github.io/atom.xml"/>
    <subtitle>吾日三省吾身</subtitle>
    <logo>https://Yichongtian.github.io/images/avatar.png</logo>
    <icon>https://Yichongtian.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Onion|个人博客</rights>
    <entry>
        <title type="html"><![CDATA[[面试题]MySQL]]></title>
        <id>https://Yichongtian.github.io/post/mian-shi-ti-mysql/</id>
        <link href="https://Yichongtian.github.io/post/mian-shi-ti-mysql/">
        </link>
        <updated>2023-05-04T13:41:17.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>undolog和redolog的区别</strong><br>
undolog记录的是逻辑日志，需要回滚时通过逆向操作恢复原来的数据<br>
redolog记录的是物理日志，定期将脏页刷新到磁盘中（先刷新到缓冲区，再刷新到系统缓冲，再刷新到磁盘）<br>
redolog保证了事务的持久性，undolog保证了事务的一致性和原子性<hr/>
</li>
<li><strong>事务的隔离性怎么保证</strong> / <strong>解释一下MVCC</strong><br>
MVCC+排他锁（一个事务获取了一行的排他锁，其他事务不能获取改行的其他锁）<br>
通过三个部分：隐藏字段 -&gt; undolog版本链 -&gt; readView<br>
隐藏字段为：最近一次修改该行的事务id、上一个版本的记录地址，（还有个ROW_ID这里用不上）<br>
事务中的每一个修改操作都会对这个版本链进行更新，更新的内容除了逻辑操作外还有上述两个隐藏字段，读的时候会产生readView，根据readView中的数据和<strong>版本</strong>链来比较来判断读取哪个<strong>版本</strong>（个人总结为找到最晚提交的事务），不同隔离级别生成readView规则不同。</li>
</ol>
<hr/>
<ol start="3">
<li><strong>什么是索引</strong>/<strong>底层数据结构</strong><br>
索引是一种通过空间换时间的数据结构，可以加快查询的速度，降低IO成本（无需全盘扫描）<br>
InnoDB引擎采用B+树，矮胖树，阶数多，路径短，好处是非叶子节点只存储指针，索引一页里面可以存很多指针，也就降低了磁盘IO。<br>
B树和B+树区别：B树的非叶子节点也会存放数据，范围查询的时候B+树效率更高（双向链表）</li>
</ol>
<hr/>
<ol start="4">
<li><strong>如何定位慢查询</strong><br>
有一些别的工具可以用，也可以用mysql自带的慢查询日志，默认是关闭的，通过设置快慢阈值来记录超过阈值的查询语句</li>
</ol>
<hr/>
<ol start="5">
<li><strong>找到了很慢的SQL，怎么分析他呢</strong><br>
用EXPLAIN来查看执行情况<br>
possible keys可能用到的索引，key用到的索引，key_len索引长度，通过<code>key和key_len</code>来判断是否命中索引，<code>Extra</code>可能会有额外的优化建议（例如Using index condition就是使用了索引但是还需要回表查询），<code>type</code>为sql的连接类型，性能由好到差为NULL(未使用表), system(使用系统表), const(根据主键查询), eq_ref(主键索引/唯一索引), ref(索引), range(带索引的范围查询), index(遍历索引树), all(全盘扫描)</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[JVM]内存管理]]></title>
        <id>https://Yichongtian.github.io/post/jvmnei-cun-guan-li/</id>
        <link href="https://Yichongtian.github.io/post/jvmnei-cun-guan-li/">
        </link>
        <updated>2023-05-02T11:39:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="内存区域划分">内存区域划分</h1>
<figure data-type="image" tabindex="1"><img src="https://Yichongtian.github.io/post-images/1683034516952.jpg" alt="" loading="lazy"></figure>
<h2 id="大致划分">大致划分</h2>
<h3 id="程序计数器">程序计数器</h3>
<p>占用很小一部分，可以看作是当前线程所执行的字节码的行号指示器。每个线程都有一个独立的程序计数器。其生命周期与该程序计数器所属线程的生命周期相同</p>
<h3 id="虚拟机栈">虚拟机栈</h3>
<p>虚拟机栈用来保存每个方法的栈帧（栈帧由局部变量表、操作数栈、动态链接、返回地址和一些附加信息构成）<br>
模拟一下虚拟机栈的运作流程：</p>
<pre><code class="language-java">public class Main {
    public static void main(String[] args) {
        int res = a();
        System.out.println(res);
    }

    public static int a(){
        return b();
    }

    public static int b(){
        return c();
    }

    public static int c(){
        int a = 10;
        int b = 20;
        return a + b;
    }
}
</code></pre>
<p><img src="https://Yichongtian.github.io/post-images/1683035594850.png" alt="" loading="lazy"><br>
在main方法中，需要调用方法a()，这时当前方法就不会继续向下运行了，而是去执行方法a()，那么同样的，将此方法也入栈，注意是放入到栈顶位置，main方法的栈帧会被压下去：<br>
<img src="https://Yichongtian.github.io/post-images/1683035600347.png" alt="" loading="lazy"><br>
这时，进入方法a之后，又继而进入到方法b，最后在进入c，因此，到达方法c的时候，我们的虚拟机栈变成了：<br>
<img src="https://Yichongtian.github.io/post-images/1683035604797.png" alt="" loading="lazy"><br>
现在我们依次执行方法c中的指令，最后返回a+b的结果，在方法c返回之后，也就代表方法c已经执行结束了，栈帧4会自动出栈，这时栈帧3就得到了上一栈帧返回的结果，并继续执行，但是由于紧接着马上就返回，所以继续重复栈帧4的操作，此时栈帧3也出栈并继续将结果交给下一个栈帧2，最后栈帧2再将结果返回给栈帧1，然后栈帧1就可以继续向下运行了，最后输出结果。<br>
<img src="https://Yichongtian.github.io/post-images/1683035679207.png" alt="" loading="lazy"></p>
<h3 id="本地方法栈">本地方法栈</h3>
<p>本地方法栈与虚拟机栈作用差不多，但是它是为本地方法准备的。</p>
<h3 id="堆">堆</h3>
<p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，作用是存放和管理对象和数组，垃圾回收主要就是在对堆进行操作</p>
<h3 id="方法区">方法区</h3>
<p>Java程序共享，存储所有类信息、常量、静态变量等，方法区由<code>类信息表</code>和<code>运行时常量池</code>构成<br>
<img src="https://Yichongtian.github.io/post-images/1683036038100.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[MySQL]进阶4（InnoDB引擎）]]></title>
        <id>https://Yichongtian.github.io/post/mysqljin-jie-4innodb-yin-qing/</id>
        <link href="https://Yichongtian.github.io/post/mysqljin-jie-4innodb-yin-qing/">
        </link>
        <updated>2023-05-01T16:13:23.000Z</updated>
        <content type="html"><![CDATA[<h1 id="逻辑存储结构">逻辑存储结构</h1>
<ol>
<li><strong>Tablespace</strong>（表空间）是InnoDB存储数据的最大单位,每个表都至少有一个表空间。表空间包含了表<br>
的数据、索引和元数据等信息。</li>
<li><strong>Segment</strong>（段） InnoDB存储数据的逻辑单位</li>
<li><strong>Extent</strong>（区）一个区是连续的磁盘空间，大小通常为1MB，每个区只于- -个段。</li>
<li><strong>Page</strong>（页） 一个页的大小通常为16KB, InnoDB存储数据的最小单位就是页。</li>
<li><strong>Row</strong>（行）具体数据</li>
</ol>
<h1 id="架构">架构</h1>
<h2 id="in-memory-structures-内存结构">In-Memory Structures 内存结构</h2>
<ol>
<li><strong>Buffer Pool</strong>，在增删改查的时候，先操作缓冲池中的数据，再以一定频率刷新到磁盘，以Page为单位</li>
<li><strong>Change Buffer</strong>，更改缓冲区，主要针对非唯一的二级索引，发现Page不在Buffer Pool中，先将变更后的数据存储在Change Buffer中，在之后数据被读取的时候，再将数据合并到Buffer Pool中。</li>
<li><strong>Adaptive Hash Index</strong>，优化对Buffer Pool的查询</li>
<li><strong>Log Buffer</strong>，日志缓冲区保存redo log，undo log，默认大小16M，定期刷新到磁盘</li>
</ol>
<h2 id="on-disk-structures-磁盘结构">On-Disk Structures 磁盘结构</h2>
<ol>
<li><strong>System Tablespace</strong> 是 MySQL 存储系统元数据的默认位置。这个表空间包含了系统表（比如 <code>mysql.*</code>，<code>performance_schema.*</code> 和 <code>information_schema.*</code>）。在 InnoDB 存储引擎中，System Tablespace 包括了数据字典和共享表空间。</li>
<li><strong>File-Per-Table Tablespaces</strong> 为每个表单独创建的一个磁盘文件。</li>
<li><strong>General Tablespaces</strong> 允许多个表共享一个表空间，这样可以更好地利用磁盘空间和提高管理效率。</li>
<li><strong>Temporary Tablespaces</strong>存储临时表和排序所创建的表空间。</li>
<li><strong>Undo Tablespaces</strong> 是用于实现事务的回滚和 MVCC 特性的表空间。</li>
<li><strong>Doublewrite Buffer Files</strong> 是用于保护数据页免受磁盘写入过程中损坏的缓冲区。在每次数据页写入磁盘前，都会先写入 Doublewrite Buffer Files。</li>
<li><strong>Redo Log</strong> 是用于记录数据更改操作的日志，用于恢复数据库。</li>
</ol>
<h2 id="后台线程">后台线程</h2>
<p>在合适的时间将缓冲池中的数据刷新到磁盘文件中。</p>
<ol>
<li><strong>Master Thread</strong>：InnoDB 启动时启动，负责管理其他后台线程。</li>
<li><strong>IO Thread</strong>：在后台启动多个 IO 线程，这些线程负责处理磁盘 I/O 请求。</li>
<li><strong>Purge Thread</strong>：用于删除已经提交的事务的 undo 日志。</li>
<li><strong>Page Cleaner Thread</strong>：定期扫描内存中的脏页，并将它们写入到磁盘。</li>
</ol>
<h1 id="事务原理">事务原理</h1>
<h2 id="redo-log">redo log</h2>
<p>持久性由 redo log实现<br>
重做日志——记录事务提交时数据页的物理修改，在mysql中，如果修改了数据，那么事务提交前，首先会被记录成redo日志写入磁盘，等到事务提交时，再把新数据写入磁盘。<br>
这也就是经常说的WAL（Write-Ahead Logging）。<br>
<img src="https://Yichongtian.github.io/post-images/1683202957592.png" alt="" loading="lazy"></p>
<h3 id="redo写入磁盘流程">redo写入磁盘流程</h3>
<ol>
<li>将上文提到的一组redo log写入redo log buffer（依然在内存中，依旧是为了调节CPU与磁盘写入速度的矛盾）。</li>
<li>redo log buffer写入page cache（操作系统里的页，操作系统会找个时间自动刷到磁盘。或者你调用fsync函数就能确保刷盘）。</li>
<li>page cache的数据刷到磁盘。</li>
</ol>
<h2 id="undo-log">undo log</h2>
<p>原子性由 undo log实现<br>
undo log记录的是逻辑日志，可以理解为：redolog记录了具体数据，undolog记录了修改过程，undolog用来提供事务回滚和MVCC（多版本并发控制）<br>
undolog在事务执行时产生，事务提交时并不会立即删除undolog，因为这些日志还可能用于MVCC</p>
<h1 id="mvcc">MVCC</h1>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>当前读<br>
读取最新的版本，可以读取到别的事务提交的记录<br>
select ... lock in share mode(共享锁)</li>
<li>快照读<br>
普通的select就是快照读（不加锁）读取的可能是历史记录<br>
在RR隔离级别（默认）下，开启事务后的第一个select会产生一个快照，后面的select都是读取的该快照<br>
RC隔离级别下，每次select都生成一个快照<br>
串行化隔离级别下，快照读 退化成 当前读</li>
<li>MVCC<br>
Multi-Version Concurrency Control，多版本并发控制<br>
维护一个数据库的多个版本，使读写操作没有冲突<br>
MVCC的实现依赖于 数据库记录中的三个隐式字段、undolog、readView</li>
</ul>
<h2 id="实现原理">实现原理</h2>
<ul>
<li>记录中的三个隐式字段<br>
显式字段就是我们自己创建的字段，但是还有两个innodb引擎帮我们添加的字段，没有主键的时候为三个字段</li>
</ul>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB_TRX_ID</td>
<td>记录插入这条记录或最后一次修改该记录的事务id</td>
</tr>
<tr>
<td>DB_ROLL_PTR</td>
<td>指向这条记录的上一个版本，用于配合undolog</td>
</tr>
<tr>
<td>DB_ROW_ID</td>
<td>表结构没有主键则生成该隐藏字段作为主键</td>
</tr>
</tbody>
</table>
<ul>
<li>undo log<br>
insert的时候产生的undolog只在回滚时需要，所以事务提交以后可以被立刻删除<br>
update、delete的时候，快照读的时候也需要（因为快照读历史），所以不会被立刻删除</li>
<li>undo log版本链<br>
不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表头部为最新的旧纪录，链表尾部是最老的旧纪录</li>
<li>readView<br>
readView记录当前活跃的事务id（未提交的事务），快照读读取redolog的哪一个版本是由readView决定的<br>
RC隔离级别下，每次快照读都会产生一个readView<br>
<img src="https://Yichongtian.github.io/post-images/1683206621403.png" alt="" loading="lazy"><br>
RR隔离级别下，仅在第一次执行快照读时生成readView，后面一直用该readView</li>
</ul>
<p>MVCC + 锁机制 实现了数据库的隔离性<br>
redolog和undolog实现了数据库的一致性</p>
<h1 id="总结">总结</h1>
<ol>
<li><strong>逻辑存储结构</strong><br>
表空间，段，区（1M），页（16K），行，一个区64个连续页，分配空间时会一次性申请4-5个区保证页是连续的</li>
<li><strong>架构</strong><br>
内存结构-缓冲区，对于一个数据库服务器大部分内存都是缓冲区<br>
磁盘结构-各种表空间，log，双写缓冲文件</li>
<li><strong>事务原理</strong><br>
原子性-undolog（回滚）<br>
持久性-redolog（写到磁盘）<br>
一致性-undolog+redolog<br>
隔离性-MVCC+锁</li>
<li><strong>MVCC</strong><br>
记录隐藏字段 --&gt; 形成了undolog版本链中的数据 --&gt; 供给readView查询</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Java]AOP]]></title>
        <id>https://Yichongtian.github.io/post/javaaop/</id>
        <link href="https://Yichongtian.github.io/post/javaaop/">
        </link>
        <updated>2023-04-30T08:40:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="动态代理模式">动态代理模式</h1>
<p>一个接口：</p>
<pre><code class="language-java">public interface Calculator {
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
}
</code></pre>
<p>一个实现类:</p>
<pre><code class="language-java">public class CalculatorImpl implements Calculator {
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println(&quot;方法内部 result = &quot; + result);
        return result;
    }
    /*
    * ...省略
    */
}
</code></pre>
<p>这时我们需要一个用于生产代理对象的工厂类，只需要把需要做额外功能的对象传进去，就可以拿到想要的代理对象，下面这段代码是一个动态代理工厂类 ProxyFactory，它的作用是通过传入一个目标对象 target，返回该对象的代理对象。</p>
<pre><code class="language-java">public class ProxyFactory {

    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getProxy(){
        /*
        *  创建代理对象的过程
        */
        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }
}
</code></pre>
<p>Proxy类是实现动态代理的关键，它提供了一个静态方法<code>newProxyInstance()</code>来创建一个代理对象，该代理对象实现了指定接口的所有方法，并将这些方法的调用委托给<code>InvocationHandler</code>接口的实现类来处理。<br>
<code>newProxyInstance()</code>方法接收三个参数：<code>ClassLoader</code>，接口数组和<code>InvocationHandler</code>接口的实现类。<code>ClassLoader</code>用于加载代理类，接口数组表示需要实现的接口，<code>InvocationHandler</code>接口的实现类用于处理代理对象的方法调用。</p>
<ol>
<li>首先获取目标对象的 <code>ClassLoader</code> 和实现的接口数组，</li>
<li>然后定义了一个 <code>InvocationHandler</code> 对象，该对象是代理对象的回调处理器，用于在代理对象方法调用前后添加额外的逻辑。在这个回调处理器中，我们可以通过 <code>method</code> 参数获取代理对象方法的相关信息，如方法名、参数等，并在方法执行前后打印日志，</li>
<li>最后通过 <code>method.invoke()</code> 方法调用目标对象的方法。最后，我们通过 <code>Proxy.newProxyInstance()</code> 方法创建代理对象并返回。</li>
</ol>
<pre><code class="language-java">public Object getProxy(){
    // ClassLoader：加载动态生成的代理类的类加载器
    ClassLoader classLoader = target.getClass().getClassLoader();
    // Class[] interfaces：目标对象实现的所有接口的class对象所组成的数组
    Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();
    // InvocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
    InvocationHandler invocationHandler = new InvocationHandler() {
        /**
         * proxy：代理对象
         * method：代理对象需要实现的方法，即其中需要重写的方法
         * args：method所对应方法的参数
         */
        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            System.out.println(&quot;[动态代理][日志]&quot; + method.getName() + &quot;， 参数: &quot; + Arrays.toString(args) + &quot; 执行前... &quot;);
            Object result = method.invoke(target, args);
            System.out.println(&quot;[动态代理][日志]&quot; + method.getName() + &quot;， 结果: &quot; + result + &quot; 执行结束... &quot;);
            return result;
        }
    };

    return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
}   
</code></pre>
<h1 id="五种通知">五种通知</h1>
<p>在Spring中，要对一个方法进行增强，我们需要引入下面的依赖：</p>
<pre><code class="language-xml">&lt;!--spring aop依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
    &lt;version&gt;6.0.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;!--spring aspects依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
    &lt;version&gt;6.0.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后得创建一个切面类，切面类需要做的事情：设置切入点、设置通知类型<br>
切面类需要用到<code>@Aspect</code>注解和<code>@Component</code>注解，<code>@Aspect</code>表示这个类是一个切面类，<code>@Component</code>注解保证这个切面类能够放入IOC容器，所以还需要将这个切面类交给IoC容器处理，所以需要开启包扫描，并配置开启AspectJ的自动代理，为目标对象自动生成代理</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.shou.aopAnnotation&quot;&gt;&lt;/context:component-scan&gt;
&lt;aop:aspectj-autoproxy /&gt;
</code></pre>
<p>共有5种通知类型：</p>
<ul>
<li>前置通知：使用<code>@Before</code>注解标识，在被代理的目标方法前执行</li>
<li>返回通知：使用<code>@AfterReturning</code>注解标识，在被代理的目标方法成功结束后执行（寿终正寝）</li>
<li>异常通知：使用<code>@AfterThrowing</code>注解标识，在被代理的目标方法异常结束后执行（死于非命）</li>
<li>后置通知：使用<code>@After</code>注解标识，在被代理的目标方法最终结束后执行（盖棺定论）</li>
<li>环绕通知：使用<code>@Around</code>注解标识，使用<code>try...catch...finally</code>结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p><strong>切入点表达式</strong>：<br>
<img src="https://Yichongtian.github.io/post-images/1682945244319.png" alt="" loading="lazy"></p>
<pre><code class="language-java">// 前置 @Before(value = &quot;切入点表达式配置切入点&quot;)
@Before(&quot;execution(public int com.shou.aopAnnotation.CalculatorImpl.*(..)) &quot;)
public void beforeMethod(JoinPoint joinPoint){
    Object[] args = joinPoint.getArgs();
    System.out.println(&quot;Logger--&gt;前置通知, 方法参数：&quot;+ Arrays.toString(args));
}

// 后置 @After()
@After(&quot;execution(public int com.shou.aopAnnotation.CalculatorImpl.*(..))&quot;)
public void afterMethod(JoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt; &quot;+methodName +&quot; 的后置通知&quot;);
}

// 返回 @AfterReturning
@AfterReturning(value = &quot;execution(public int com.shou.aopAnnotation.CalculatorImpl.*(..))&quot;, returning = &quot;result&quot;)
public void afterReturningMethod(JoinPoint joinPoint, Object result){
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt; &quot;+methodName +&quot; 的返回通知， result = &quot;+result);
}

// 异常 @AfterThrowing
@AfterThrowing(value = &quot;execution(* com.shou.aopAnnotation.CalculatorImpl.*(..))&quot;, throwing = &quot;ex&quot;)
public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;Logger--&gt; &quot;+methodName +&quot; 的异常通知: &quot;+ex);
}

// 环绕 @Around()
@Around(&quot;execution(* com.shou.aopAnnotation.CalculatorImpl.*(..))&quot;)
public Object afterThrowingMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    Object result = new Object();
    try {
        System.out.println(&quot;========环绕通知========执行前&quot;);
        result = joinPoint.proceed();
        System.out.println(&quot;========环绕通知========目标方法返回值之后&quot;);
    }catch (Throwable throwable){
        throwable.printStackTrace();
        System.out.println(&quot;========环绕通知========目标方法出现异常&quot;);
    }finally {
        System.out.println(&quot;========环绕通知========目标方法执行完毕&quot;);
    }
    return result;
}
</code></pre>
<p>通过上面的例子我们发现多个增强的切入点表达式是一样的，为了减少冗余，可以使用<strong>重用切入点表达式</strong>在切面类中声明如下方法：</p>
<pre><code class="language-java">@Pointcut(&quot;execution(public int com.shou.aopAnnotation.CalculatorImpl.*(..))&quot;)
public void pointCut(){}
</code></pre>
<p>使用时只需要在切面表达式value中写pointCut()就好了<code>@Before(&quot;pointCut()&quot;)</code></p>
<h1 id="切面优先级">切面优先级</h1>
<p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的<strong>内外嵌套</strong>顺序。</p>
<ul>
<li>优先级高的切面：外面</li>
<li>优先级低的切面：里面</li>
</ul>
<p>使用@Order注解可以控制切面的优先级：</p>
<ul>
<li>@Order(较小的数)：优先级高</li>
<li>@Order(较大的数)：优先级低<br>
<img src="https://Yichongtian.github.io/post-images/1682945779551.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Java]复习一下反射]]></title>
        <id>https://Yichongtian.github.io/post/javafu-xi-yi-xia-fan-she/</id>
        <link href="https://Yichongtian.github.io/post/javafu-xi-yi-xia-fan-she/">
        </link>
        <updated>2023-04-26T15:43:33.000Z</updated>
        <content type="html"><![CDATA[<p><strong>自定义类</strong></p>
<pre><code class="language-java">package com.shou.reflect;

public class Car {

    //属性
    private String name;
    private int age;
    private String color;

    //无参数构造
    public Car() {
    }

    //有参数构造
    public Car(String name, int age, String color) {
        this.name = name;
        this.age = age;
        this.color = color;
    }

    //普通方法
    private void run() {
        System.out.println(&quot;私有方法-run.....&quot;);
    }

    //get和set方法
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getColor() {
        return color;
    }
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String toString() {
        return &quot;Car{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, color='&quot; + color + '\'' +
                '}';
    }
}
</code></pre>
<h2 id="1-获取class对象多种方式">1. 获取Class对象多种方式</h2>
<pre><code class="language-java">@Test
public void test01() throws Exception {
    //1 类名.class
    Class&lt;Car&gt; clazz1 = Car.class;

    //2 对象.getClass()
    Class&lt;? extends Car&gt; clazz2 = new Car().getClass();

    //3 Class.forName(&quot;全路径&quot;)
    Class&lt;?&gt; clazz3 = Class.forName(&quot;com.shou.bean.Car&quot;);

    //实例化
    Car car = (Car)clazz3.getDeclaredConstructor().newInstance();
    System.out.println(car);
}
</code></pre>
<h2 id="2-获取构造方法">2. 获取构造方法</h2>
<pre><code class="language-java">@Test
public void test02() throws Exception{
    Class&lt;Car&gt; clazz = Car.class;
    //getConstructors()获取所有public的构造方法
    //getDeclaredConstructors()获取所有的构造方法
    Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();
    for (Constructor&lt;?&gt; c : declaredConstructors) {
        System.out.println(c.getName()+&quot; 方法参数个数: &quot;+c.getParameterCount());
    }

    //调用public
    Constructor&lt;Car&gt; c1 = clazz.getDeclaredConstructor(String.class, int.class, String.class);
    Car car1 = c1.newInstance(&quot;Benz&quot;, 5, &quot;香槟色&quot;);
    System.out.println(car1);

    //调用private
    Constructor&lt;Car&gt; c2 = clazz.getDeclaredConstructor(String.class, int.class, String.class);
    c2.setAccessible(true);
    Car car2 = c2.newInstance(&quot;BMW&quot;, 6, &quot;黑色&quot;);
    System.out.println(car2);
}
</code></pre>
<h2 id="3-获取属性">3. 获取属性</h2>
<pre><code class="language-java">@Test
public void test03() throws Exception{
    Class&lt;Car&gt; clazz = Car.class;
    Car car = clazz.getDeclaredConstructor().newInstance();
    //获取所有public属性
    Field[] fields1 = clazz.getFields();
    //获得所有属性（包含private）
    Field[] fields2 = clazz.getDeclaredFields();

    //给私有属性赋值
    for (Field field : fields2) {
        System.out.println(field.getType() + &quot; &quot; + field.getName());
        if( &quot;name&quot;.equals(field.getName()) ){
            field.setAccessible(true);
            field.set(car, &quot;比亚迪&quot;);
        }
    }
    System.out.println(car);
}
</code></pre>
<h2 id="4-获取方法">4. 获取方法</h2>
<pre><code class="language-java">@Test
public void test04() throws Exception{
    Car car = new Car(&quot;Tesla&quot;, 3, &quot;祖母绿&quot;);
    Class&lt;? extends Car&gt; clazz = car.getClass();

    //获取所有方法
    Method[] methods = clazz.getMethods();
    for (Method method : methods) {
        if(&quot;toString&quot;.equals(method.getName())){
            String invoke = (String)method.invoke(car);
            System.out.println(&quot;执行toString方法： &quot; + invoke);
        }
    }

    //获取我想要的私有方法
    Method[] declaredMethod = clazz.getDeclaredMethods();
    for (Method method : declaredMethod) {
        if(&quot;run&quot;.equals(method.getName())){
            method.setAccessible(true);
            method.invoke(car);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Java]手写IoC]]></title>
        <id>https://Yichongtian.github.io/post/javashou-xie-ioc/</id>
        <link href="https://Yichongtian.github.io/post/javashou-xie-ioc/">
        </link>
        <updated>2023-04-26T15:06:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定义两个注解">定义两个注解</h1>
<p>Bean注解（<code>@Component</code>）</p>
<pre><code class="language-java">package com.yct.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Bean {
}
</code></pre>
<p>Di注解（<code>@Autowired</code>）</p>
<pre><code class="language-java">package com.yct.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Di {
}
</code></pre>
<h1 id="定义bean容器接口">定义bean容器接口</h1>
<pre><code class="language-java">package com.yct.core;

public interface ApplicationContext {
    Object getBean(Class clazz);
}
</code></pre>
<h1 id="定义bean容器接口的实现类">定义bean容器接口的实现类</h1>
<pre><code class="language-java">package com.yct.core;

import java.util.HashMap;

public class OnionApplicationContext implements ApplicationContext{

    //存储bean的容器
    private HashMap&lt;Class, Object&gt; beanFactory = new HashMap&lt;&gt;();

    @Override
    public Object getBean(Class clazz) {
        return null;
    }

    /**
     * 根据包扫描加载Bean
     * @param basePackage
     */
    public OnionApplicationContext(String basePackage) {
    }
}
</code></pre>
<p><strong>构造方法：</strong></p>
<ol>
<li>
<p>将包名替换为路径：通过将包名中的 &quot;.&quot; 替换为 &quot;/&quot;，将包名转换为相对路径，用于查找类所在的绝对路径。</p>
</li>
<li>
<p>获取包的绝对路径：通过调用当前线程的上下文类加载器的 getResources() 方法，传入参数 &quot;com/yct/core&quot;，获取该包名路径下的所有资源的 URL 列表，并遍历这个列表。</p>
</li>
<li>
<p>获取绝对路径的前面部分：因为所有类前面的一大截路径都是一样的，所以可以通过获取相对路径的前面部分，即包名所在的路径即可确定所有类的主路径 rootPath 。</p>
</li>
<li>
<p>加载类文件：将获取到的所有类文件递归加载到容器中。这里的 loadBean() 方法需要读取相应类文件的全名，并且把类名首字母小写作为 key ，将 class 对象与其对应起来，以供后续使用。</p>
</li>
</ol>
<pre><code class="language-java">//1. 将包名替换为路径: com.yct.core -&gt; com/yct/core
String basePackagePath = basePackage.replaceAll(&quot;\\.&quot;, &quot;/&quot;);

//2. 获取包的绝对路径（带盘符）
Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(basePackagePath);

while (urls.hasMoreElements()){
    URL url = urls.nextElement();
    String filePath = URLDecoder.decode(url.getFile(), &quot;utf-8&quot;);

    //获取路径的前面部分，因为所有的包前面的一大截路径都是一样的
    rootPath = filePath.substring(0, filePath.length()-basePackagePath.length());
    loadBean(new File(filePath));
}
</code></pre>
<p>这段代码中的关键代码在于逐个遍历包路径下的所有类，并将类名与 class 对象对应起来，用于后续的组装操作。该操作通常在一些框架或者中间件中会经常用到，应用较为广泛。<br>
再来看看<code>loadBean(new File(filePath))</code>方法：<br>
<code>loadBean</code>实现的功能是从指定的文件中加载所有被 @Bean 注解标记的类，并实例化这些类的对象，最终将这些对象存储到 <code>beanFactory</code> 集合中。</p>
<ol>
<li>判断传入的 file 是否为文件夹。</li>
<li>如果 file 是文件夹，则获取文件夹中的所有内容。</li>
<li>如果文件夹为空，直接返回。</li>
<li>如果文件夹不为空，则遍历文件夹中的所有内容。
<ol>
<li>如果遍历得到的是文件夹，递归调用 loadBean() 方法，继续判断其中的内容。</li>
<li>如果遍历得到的不是文件夹，则将其路径中的文件分隔符替换为点号，去掉 .class 后缀，得到完整的类名。</li>
<li>判断得到的类是否被 @Bean 注解标记。
<ol>
<li>获取类的 <code>Class</code> 对象。</li>
<li>判断类是否为接口。</li>
<li>如果类不是接口，则获取该类上的 <code>@Bean</code> 注解。</li>
<li>如果类上有 <code>@Bean</code> 注解，则使用 <code>clazz.getConstructor().newInstance()</code> 实例化该类的对象，并将对象存储到 <code>beanFactory</code> 集合中。如果该类实现了接口，则使用接口作为键，否则使用该类作为键。</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code class="language-java">private void loadBean(File file) throws Exception {
    // 判断给定的文件是否是一个目录
    if(file.isDirectory()){
        // 获取目录中的所有文件
        File[] childFiles = file.listFiles();
        // 如果目录为空，返回
        if(childFiles == null || childFiles.length == 0){
            return;
        }
        // 遍历目录中的所有文件
        for (File childFile : childFiles) {
            // 如果文件是一个目录，则递归调用 loadBean() 方法
            if(childFile.isDirectory()){
                loadBean(childFile);
            }else{
                // 获取文件的绝对路径，并将路径中的 '\' 替换为 '.'
                String pathWithClass = childFile.getAbsolutePath().substring(rootPath.length() - 1);
                pathWithClass = pathWithClass.replaceAll(&quot;\\\\&quot;, &quot;.&quot;);
                // 如果文件是 .class 文件
                if(pathWithClass.endsWith(&quot;.class&quot;)){
                    // 去掉 .class 后缀，得到类的完整路径
                    String fullName = pathWithClass.replace(&quot;.class&quot;, &quot;&quot;);
                    // 根据完整路径获取 Class 对象
                    Class&lt;?&gt; clazz = Class.forName(fullName);
                    // 如果不是接口
                    if( !clazz.isInterface() ){
                        // 获取类上的 @Bean 注解
                        Bean clazzAnnotation = clazz.getAnnotation(Bean.class);
                        // 如果有 @Bean 注解，则实例化对象
                        if(clazzAnnotation != null){
                            Object o = clazz.getConstructor().newInstance();
                            // 如果类实现了接口，使用接口作为 key 放到 beanFactory 中
                            if(clazz.getInterfaces().length &gt; 0){
                                beanFactory.put(clazz.getInterfaces()[0], o);
                            }else{
                                // 如果类没有实现接口，则使用类本身作为 key 放到 beanFactory 中
                                beanFactory.put(clazz, o);
                            }
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
<p>然后是loadDi()方法：目的是实现自动装配，即通过扫描所有已实例化的对象，寻找其中带有@Di注解的属性，然后将属性类型与beanFactory中存储的对象匹配，如果匹配成功，则通过反射将对应的对象注入到属性中。具体实现过程如下（注意，这里的自动装配是基于属性类型匹配的，所以属性类型必须与beanFactory中存储的对象类型一致或为其子类，否则自动装配将无法成功。）：</p>
<ol>
<li>首先获取beanFactory中存储的所有对象的entrySet。</li>
<li>遍历entrySet，获取每个对象obj。</li>
<li>获取obj的所有属性fields。</li>
<li>遍历fields，判断属性上是否有@Di注解。</li>
<li>如果有，将属性设置为可访问，然后通过反射获取属性类型，并在beanFactory中查找是否存在该类型对应的对象。</li>
<li>如果存在，则将该对象注入到属性中。</li>
</ol>
<pre><code class="language-java">private void loadDi() throws IllegalAccessException {
    // 首先获取beanFactory中存储的所有对象的entrySet。
    Set&lt;Map.Entry&lt;Class, Object&gt;&gt; entrySet = beanFactory.entrySet();
    for (Map.Entry&lt;Class, Object&gt; entry : entrySet) {
        // 遍历entrySet，获取每个对象obj。
        Object obj = entry.getValue();
        // 获取obj的所有属性fields。
        Field[] fields = obj.getClass().getDeclaredFields();
        for (Field field : fields) {
            // 遍历fields，判断属性上是否有@Di注解。
            Di di = field.getAnnotation(Di.class);
            if(di != null){
                // 如果有，将属性设置为可访问，然后通过反射获取属性类型，并在beanFactory中查找是否存在该类型对应的对象。
                field.setAccessible(true);
                field.set(obj, beanFactory.get(field.getType()));
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[面经]im the jumpmaster，duo~]]></title>
        <id>https://Yichongtian.github.io/post/mian-jing/</id>
        <link href="https://Yichongtian.github.io/post/mian-jing/">
        </link>
        <updated>2023-04-26T14:29:52.000Z</updated>
        <content type="html"><![CDATA[<h2 id="resource和autowired的区别"><code>@Resource</code>和<code>@Autowired</code>的区别</h2>
<p><code>@Autowird</code>为Spring提供的注解，默认装配规则为根据类型<code>byType</code>（如果要根据名称装配，需要配合@Qualifier）<br>
<code>@Resource</code>是JDK扩展包中的，属于JDK的一部分，更具有通用性，默认装配规则为根据名字<code>byName</code>，通过name找不到的时候才会根据类型装配</p>
<p><code>@Autowired</code>注解用在<code>属性</code>上、<code>setter方法</code>上、<code>构造方法</code>上、<code>构造方法参数</code>上，而<br>
<code>@Resource</code>注解用在<code>属性</code>上、<code>setter方法</code>上</p>
<hr/>
<h2 id="bean的作用域和生命周期"><code>bean</code>的作用域和生命周期</h2>
<p><strong>作用域</strong></p>
<p>在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义参加下表：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
<th>创建对象的时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>singleton（默认）</td>
<td>在IOC容器中，这个bean的对象始终为单实例</td>
<td>IOC容器初始化时</td>
</tr>
<tr>
<td>prototype</td>
<td>这个bean在IOC容器中有多个实例</td>
<td>获取bean时</td>
</tr>
</tbody>
</table>
<p>如果是在WebApplicationContext环境下还会有另外几个作用域（但不常用）：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>在一个请求范围内有效</td>
</tr>
<tr>
<td>session</td>
<td>在一个会话范围内有效</td>
</tr>
</tbody>
</table>
<pre><code class="language-xml">&lt;!-- scope属性：取值singleton（默认值），bean在IOC容器中只有一个实例，IOC容器初始化时创建对象 --&gt;
&lt;!-- scope属性：取值prototype，bean在IOC容器中可以有多个实例，getBean()时创建对象 --&gt;
&lt;bean class=&quot;com.atguigu.spring6.bean.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
</code></pre>
<p><strong>生命周期</strong></p>
<ul>
<li>bean对象创建（调用无参构造器）</li>
<li>给bean对象设置属性</li>
<li>bean的后置处理器（初始化之前）</li>
<li>bean对象初始化（需在配置bean时指定初始化方法）</li>
<li>bean的后置处理器（初始化之后）</li>
<li>bean对象就绪可以使用</li>
<li>bean对象销毁（需在配置bean时指定销毁方法）</li>
<li>IOC容器关闭</li>
</ul>
<hr/>
<h2 id="数据库索引的原理创建索引的缺点是什么什么情况下索引失效优化数据库的方法">数据库索引的原理？创建索引的缺点是什么？什么情况下索引失效？优化数据库的方法？</h2>
<p><strong>关键点：</strong></p>
<ol>
<li>哪种数据库（其实关系型数据库都差不多）</li>
<li>以MySQL为例的b+树</li>
<li>索引好处和代价</li>
<li>索引失效情况</li>
<li>优化
<ol>
<li>硬件层面</li>
<li>软件层面<br>
答：</li>
</ol>
</li>
</ol>
<h3 id="原理">原理</h3>
<ol>
<li>MySQL默认引擎InnoDB使用b+树实现索引，在索引查找时时间复杂度为log(n)</li>
<li>索引又分为聚簇索引和非聚簇索引，聚簇索引是建表的时候引擎自动创建的，记录了主键id和完整的一行数据，非聚簇索引由用户自行创建，记录的数据是用户自行决定的字段以及该字段对应的主键，如果需要完整的数据需要用这个主键去聚簇索引中再次查找完整的记录，这个过程叫回表查询</li>
<li>索引的叶子节点以链表的形式存储，方便顺序查找和排序</li>
</ol>
<h3 id="代价">代价</h3>
<ol>
<li>占用空间（空间换时间，存储在磁盘，缓存在内存）</li>
<li>对建立了索引的表进行更新时会级联更新索引</li>
<li>高并发写影响性能</li>
</ol>
<h3 id="索引失效的情况">索引失效的情况</h3>
<ol>
<li>计算、函数</li>
<li>LIKE以%开头</li>
<li>不等于（!= 或 &lt;&gt;）</li>
<li>is not null可能失效</li>
<li>类型转换</li>
<li>数据库优化器觉得不使用索引会更快的时候</li>
</ol>
<h3 id="优化数据库的方法">优化数据库的方法</h3>
<ol>
<li>表结构设计优化，尽可能减少跨表查询，可以添加冗余字段，控制容量</li>
<li>sql优化，覆盖索引，select * -&gt;select字段，where条件尽可能精准，等值匹配放在前面，范围匹配放在后面，使用order by的时候最好按照最左前缀法则建立索引</li>
<li>减少函数的使用</li>
</ol>
<hr/>
<h2 id="什么是spring依赖注入有哪些方法">什么是Spring依赖注入，有哪些方法</h2>
<p>依赖注入是指将要用到的对象实例交给Spring的IoC容器帮我们管理，方法：set方法注入，构造方法注入，autowird注入（默认ByType，可以改为ByName）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[MySQL]进阶3（锁）]]></title>
        <id>https://Yichongtian.github.io/post/mysqljin-jie-3suo/</id>
        <link href="https://Yichongtian.github.io/post/mysqljin-jie-3suo/">
        </link>
        <updated>2023-04-17T14:36:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概述">概述</h1>
<p>MySQL中的锁，按照<code>粒度</code>，分为三类：<code>全局锁</code>、<code>表级锁</code>、<code>行级锁</code></p>
<pre><code class="language-sql">#查看当前锁
select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;
</code></pre>
<h1 id="全局锁">全局锁</h1>
<p>对整个数据库实例加锁，加锁后整个实例处于只读状态，后续的<code>DML写</code>、<code>DDL</code>、<code>进行了更新操作的事务的提交</code>语句都将被阻塞。<br>
一般是全库备份的时候使用，否则可能导致数据不一致。</p>
<pre><code class="language-sql">flush tables with read lock; #上锁
unlock tables; #解锁
</code></pre>
<p>在InnoDB中，可以通过<code>--single-transaction</code>参数完成不加锁的数据一致性备份</p>
<pre><code class="language-sql">mysqldump --single-transaction -h localhost -u root -p root mydb&gt;mydb01.sql
</code></pre>
<h1 id="表级锁">表级锁</h1>
<p>每次锁整张表，锁的粒度大，发生锁冲突的概率最高，并发度最低，分为<code>表锁</code>、<code>元数据锁(meta data lock, MDL)</code>、<code>意向锁</code></p>
<ul>
<li>表锁<br>
又分为<code>表共享读锁(read lock)</code>、<code>表独占写锁(write lock)</code><br>
<code>表共享读锁(read lock)</code>：为了读数据而加锁，防止读到不一致的数据，读锁不会阻塞读，但会阻塞写。<br>
<code>表独占写锁(write lock)</code>：一旦某张表被某个会话佳了写锁，那么这个会话既能读又能写，别的会话既不能读也不能写</li>
<li>元数据锁(meta data lock, MDL)<br>
MySQL5.5引入的MDL，加锁过程是自动的，目的是避免DML与DDL冲突，对表进行增删改查的时候加MDL读锁（共享），在修改表结构的时候加MDL写锁（排他）</li>
<li>意向锁
<ol>
<li>意向共享锁（IS）：与表锁共享锁(read) 兼容,与表锁排它锁(write) 互斥。</li>
<li>意向排他锁（IX）：与表锁共享锁(read) 及排它锁(write) 都互斥。意向锁之间不会互斥。</li>
</ol>
</li>
</ul>
<h1 id="行级锁">行级锁</h1>
<p>每次锁住对应行，锁的粒度最小，发生锁冲突的概率最低，并发度最高，行级锁主要分为<code>行锁</code>，<code>间隙锁</code>，<code>临键锁</code></p>
<ul>
<li><code>行锁（Record Lock）</code>：锁定单个记录，防止其他事务对此纪录进行update和delete，在RC、RR隔离级别下都支持。InnoDB有两种类型的行锁：<code>共享锁（S）</code>（允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁）和<code>排他锁（X）</code>（允许那个获得了排他锁的事务进行数据更新，阻止其他事务获得相同数据集的排他锁和共享锁）</li>
</ul>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT...</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>UPDATE...</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>DELETE...</td>
<td>排他锁</td>
<td>自动加锁</td>
</tr>
<tr>
<td>SELECT...（正常）</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>SELECT...LOCK IN SHARE MODE</td>
<td>共享锁</td>
<td>需要手动在select后加lock in share mode</td>
</tr>
<tr>
<td>SELECT...FOR UPDATE</td>
<td>排他锁</td>
<td>需要手动在select后加for update</td>
</tr>
</tbody>
</table>
<ul>
<li><code>间隙锁（Gap Lock）</code>：锁定间隙（不锁记录），确保索引间的间隙不变，防止其他事务在这个间隙进行insert，产生幻读，在RR隔离级别下支持</li>
<li><code>临键锁（Next-Key Lock）</code>：行锁和间隙锁的组合，在RR下支持<br>
InnoDB在默认情况下使用临键锁进行搜索和索引扫描来防止幻读：
<ul>
<li>在针对唯一索引进行检索时，对已经存在的记录进行等值匹配的时候，会将临键锁优化为行锁</li>
<li>InnoDB的行锁是针对索引加的锁，不通过索引条件检索数据，会对表中所有记录加锁，即升级为表锁</li>
</ul>
</li>
</ul>
<ol>
<li>在一个唯一索引上进行等值查询，给不存在的记录加锁时，临键锁优化为间隙锁</li>
<li>在普通索引上进行等值查询时，满足查询要求的值使用临键锁，向右遍历到最后一个不满足的行，该记录的锁为间隙锁</li>
<li>在一个唯一索引上进行范围查询，会访问到不满足条件的第一个值为止。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[MySQL]进阶2（SQL优化）]]></title>
        <id>https://Yichongtian.github.io/post/mysqljin-jie-2sql-you-hua-shi-tu-suo/</id>
        <link href="https://Yichongtian.github.io/post/mysqljin-jie-2sql-you-hua-shi-tu-suo/">
        </link>
        <updated>2023-04-16T16:18:40.000Z</updated>
        <content type="html"><![CDATA[<h1 id="sql优化">SQL优化</h1>
<h2 id="插入数据">插入数据</h2>
<ul>
<li>insert优化
<ul>
<li>建议使用一条insert语句插入多个记录而不是多个insert语句，因为每执行一次insert都需要与数据库建立连接等操作，效率会低</li>
<li>建议手动提交事务，如果自动提交的话，mysql会频繁开启事务，影响效率</li>
<li>建议按照主键顺序插入</li>
</ul>
</li>
<li>大批量插入数据<br>
推荐使用load操作而不是insert操作，load加载的文件是一种符合某种规定格式的文件<pre><code class="language-sql">#连接客户端时加上参数 --local-infile
MySQL--local-infile -u root -p
#设置全局参数local_infile为1
set global local_infile=1;
#执行load，字段以,结尾，行以换行符结尾
load data local infile 'path/xxx/xxx.xxx' into table 'tb_user' fields terminated by ',' lines terminated by '\n';
</code></pre>
</li>
</ul>
<h2 id="主键优化">主键优化</h2>
<ul>
<li>数据组织方式<br>
在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</li>
<li>页分裂<br>
页可以为空,也可以填充-半,也可以填充100%。每个页包含了2-N行数据(如果一行数据多大， 会行溢出)，根据主键排列。这就是为什么建议按照主键顺序插入，如果乱序插入，会出现狠多页分裂的情况
<blockquote>
<p>面试题：Mysql为何建议使用自增id作主键,有什么优点<br>
B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果插入的值比最大值id大，则只需要最后记录后面插入一个新记录。如果新插入的ID值在原先的有序中间，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
</blockquote>
</li>
<li>页合并<br>
删除了一些记录，当删除的记录达到MERGE_THRESHOLD(默认50%)时，InnoDB会左右看一下能不能合并两个页</li>
<li>主键设计原则<br>
尽量降低主键的长度，因为一个表可能有很多二级索引，而二级索引的叶子节点挂载的数据就是主键的值，如果主键过长，将会占用大量的磁盘空间，搜索的时候耗费磁盘IO</li>
</ul>
<h2 id="order-by优化">order by优化</h2>
<p>MySQL的排序有两种方式：<code>Using filesort</code>和<code>Using index</code><br>
<code>Using filesort</code>通过索引或者全表扫描，将所有满足条件的数据行放在排序缓冲区<code>sort buffer</code>（默认256K，可修改，超出之后在磁盘排序，性能低）<br>
<code>Using index</code>通过索引顺序扫描直接返回有序数据，不额外排序，效率高<br>
针对order by的条件建立索引即可优化为<code>Using index</code>，例如order by age asc, phone desc，则建立<code>create index idx_idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>即可</p>
<h2 id="group-by优化">group by优化</h2>
<p>跟<code>order by</code>的优化过程差不多，也是根据查询条件建立索引即可，注意满足最左前缀法则</p>
<h2 id="limit优化">limit优化</h2>
<p>一般分页查询时，通过创建覆盖索引能较好地提升性能，通过覆盖索引+子查询形式进行优化</p>
<h2 id="count优化">count优化</h2>
<ul>
<li>MyISAM引擎把一一个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数,效率很高。</li>
<li>InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来,然后累积计数。</li>
</ul>
<p><strong>优化方式</strong>：自己计数，通过Redis等方式自行维护一个count，插入自行增加删除自行减少。<br>
count的几种用法：<br>
* <code>count(主键)</code>：把每一行的值取出，返回给服务层，直接按行累加<br>
* <code>count(字段)</code>：遍历整张表取出每一行的值，分有无<code>NOT NULL</code>约束，有约束直接累加，没约束判断不为null后累加<br>
* <code>count(1)</code>：遍历整张表但是不取值，服务层对于每一行都放一个1进去直接进行累加<br>
* <code>count(*)</code>：InnoDB专门做了优化，不取值，服务层直接进行按行累加。<br>
效率：<code>count(字段)</code> &lt; <code>count(主键id)</code> &lt; <code>count(1)</code> ≈ <code>count(*)</code></p>
<h2 id="update优化">update优化</h2>
<p>针对字段有索引，事务更新时的锁为行锁，没有索引，则升级为表锁，并发性能降低</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[MySQL]进阶1（简介、索引）]]></title>
        <id>https://Yichongtian.github.io/post/mysqljin-jie/</id>
        <link href="https://Yichongtian.github.io/post/mysqljin-jie/">
        </link>
        <updated>2023-04-15T13:08:48.000Z</updated>
        <content type="html"><![CDATA[<h1 id="存储引擎">存储引擎</h1>
<h2 id="mysql体系结构">MySQL体系结构</h2>
<figure data-type="image" tabindex="1"><img src="https://Yichongtian.github.io/post-images/1681564335830.png" alt="" loading="lazy"></figure>
<h2 id="存储引擎简介">存储引擎简介</h2>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型。</p>
<ol>
<li>在创建表时，指定存储引擎<pre><code class="language-sql">CREATE TABLE table1(
     #xxx
     #xxx
 )ENGINE = INNODB;
</code></pre>
</li>
<li>查看当前数据库支持的存储引擎<pre><code class="language-sql">SHOW ENGINES;
</code></pre>
</li>
</ol>
<h2 id="存储引擎特点">存储引擎特点</h2>
<h3 id="font-colordd0000innodbfont"><font color="#dd0000">InnoDB</font></h3>
<h4 id="介绍">介绍</h4>
<p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎</p>
<h4 id="特点">特点</h4>
<p>DML操作遵循ACID模型，支持事务；<br>
行级锁，提高并发访问性能；<br>
支持外键FOREIGN KEY约束，保证数据的完整性和正确性；</p>
<h4 id="文件">文件</h4>
<p>xxx.ibd：xxx代表的是表名, innoDB引擎的每 张表都会对应这样一个表空间文件, 存储该表的表结构(frm. sdi) 、数据和索引。<br>
参数: innodb_file_per_table<br>
<img src="https://Yichongtian.github.io/post-images/1681566994640.png" alt="" loading="lazy"></p>
<h3 id="font-colordd0000myisamfont"><font color="#dd0000">MyISAM</font></h3>
<h4 id="介绍-2">介绍</h4>
<p>MyISAM是MySQL早期的默认存储引擎。</p>
<h4 id="特点-2">特点</h4>
<p>不支持事务,不支持外键<br>
支持表锁，不支持行锁<br>
访问速度快</p>
<h4 id="文件-2">文件</h4>
<p>xxx.sdi：存储表结构信息<br>
xxx.MYD：存储数据<br>
xxx.MYI：存储索引</p>
<h3 id="font-colordd0000memoryfont"><font color="#dd0000">Memory</font></h3>
<h4 id="介绍-3">介绍</h4>
<p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<h4 id="特点-3">特点</h4>
<p>内存存放<br>
hash索引（默认）</p>
<h4 id="文件-3">文件</h4>
<p>xxx.sdi：存放表结构信息</p>
<h3 id="font-colordd0000不同引擎的区别font"><font color="#dd0000">不同引擎的区别</font></h3>
<figure data-type="image" tabindex="2"><img src="https://Yichongtian.github.io/post-images/1681567449754.png" alt="" loading="lazy"></figure>
<h2 id="存储引擎选择">存储引擎选择</h2>
<p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统,还可以根据实际情况选择多种存储引擎进行组合。<br>
<code>InnoDB</code> : 是MysqI的默认存储引擎，支持<strong>事务</strong>、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。<br>
<code>MyISAM</code> :如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。<br>
<code>MEMORY</code>:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</p>
<h1 id="索引">索引</h1>
<h2 id="索引概述">索引概述</h2>
<p>索引(index) 是帮助MySQL高效获取数据的数据结构(有序)。在数据之外,数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构. 上实现高级查找算法,这种数据结构就是索引。</p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>提高数据检索的效率，降低数据库的I0成本</td>
<td>索引列也是要占用空间的。</td>
</tr>
<tr>
<td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td>
<td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、 DELETE时，效率降低。</td>
</tr>
</tbody>
</table>
<h2 id="索引结构">索引结构</h2>
<p>MySQL的索引在存储引擎层实现，不同的存储引擎有不同的索引结构：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效不支持范围查询</td>
</tr>
<tr>
<td>R-tree(空间索引)</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td>
</tr>
<tr>
<td>Full-text(全文索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES</td>
</tr>
</tbody>
</table>
<p>在不指明的情况下，大多数情况默认讨论B+Tree索引<br>
<font color="#dd0000">二叉树</font>：顺序插入时会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢<br>
<font color="#dd0000">红黑树</font>：红黑树基于二叉树的情况下做了自平衡，不会再形成链表了，解决了二叉树的第一个缺点，但是没有解决第二个<br>
<font color="#dd0000">B-Tree（<strong>多路</strong>平衡查找树）</font>：以一颗最大度数（max-degree，树的度数指的是一个节点的子节点个数）为5（5阶）的b-tree为例（每个节点最多存储4个key，5个指针）<br>
<img src="https://Yichongtian.github.io/post-images/1681632989538.png" alt="" loading="lazy"><br>
可以使用一个 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">数据结构可视化网站</a> 对B树进行模拟<br>
使用下列数据进行插入操作会有完整的树的分裂过程：</p>
<pre><code class="language-java">100 65 169 368 900 556 780 35 215 1200 234 888 158 90 1000 88 120 268 250
</code></pre>
<p><img src="https://Yichongtian.github.io/post-images/1681634079388.png" alt="" loading="lazy"><br>
向上述B树插入数据<code>250</code>，<code>250</code>在<code>169</code>和<code>556</code>之间，所以进入根节点的第三棵子树，并插入到子树的<code>234</code>和<code>268</code>之间<br>
由于最大度数为5，此时度数来到了6，不满足树的条件，所以该节点会基于中间的值进行分裂，即：将<code>250</code>插入至父节点的中间<br>
<code>215</code>和<code>234</code>重新组成处于<code>169</code>和<code>250</code>之间的子节点<code>268</code>和<code>368</code>组成<code>250</code>和<code>556</code>之间的子节点<br>
这是根节点的存储个数来到5，度数来到6，所以根节点基于中间key进行分裂，过程同上，成为：<br>
<img src="https://Yichongtian.github.io/post-images/1681634538309.png" alt="" loading="lazy"><br>
<font color="#dd0000">B+Tree</font><br>
<img src="https://Yichongtian.github.io/post-images/1681635035090.png" alt="" loading="lazy"><br>
所有数据都会出现在叶子节点，叶子节点形成一个单项列表，非叶子节点主要起到索引作用<br>
分裂时与B-Tree的区别是：分裂后那个向上分裂的key仍然会处于叶子节点中，并形成链表，图示：<br>
<img src="https://Yichongtian.github.io/post-images/1681635309968.png" alt="" loading="lazy"><br>
<font color="#dd0000">MySQL中的B+Tree</font><br>
<img src="https://Yichongtian.github.io/post-images/1681635466371.png" alt="" loading="lazy"><br>
MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p>
<blockquote>
<p>面试题<br>
为什么InnoDB存储引擎选择使用B+Tree索引结构<br>
1. 相较于二叉树，层级更少，搜索效率更高。<br>
2. 对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值变少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低。<br>
3. 相对Hash索引，B+Tree支持范围匹配及排序操作。</p>
</blockquote>
<h2 id="索引分类">索引分类</h2>
<p>在InnoDB引擎中，根据索引的存储形式，可以分为：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引(Clustered Index)</td>
<td>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td>
<td>必须有,而且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td>可以存在多个</td>
</tr>
</tbody>
</table>
<p>聚集索引选取规则：</p>
<ul>
<li>如果存在主键，主键索引就是聚集索引。</li>
<li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引</li>
<li>如果没有主键也没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li>
</ul>
<p>针对<code>select * from user where name = 'Arm';</code>这条sql语句举例，它的执行顺序如下，这一过程被称之为<strong>回表查询</strong><br>
<img src="https://Yichongtian.github.io/post-images/1681637161461.png" alt="" loading="lazy"></p>
<blockquote>
<p>测试：下面两个sql语句哪个的执行效率更高？为什么？（id为主键，name字段创建了索引）<br>
<code>select * from user where id = 10;</code><br>
<code>select * from user where name = 'Arm';</code><br>
答：第一条快，因为第一条只用查询聚集索引，而第二条要先查二级索引，再根据二级索引的结果查询聚集索引</p>
</blockquote>
<h2 id="索引语法">索引语法</h2>
<pre><code class="language-sql">#创建索引
create [UNIQUE|FULLTEXT] INDEX index_name ON table_name(col_name,...);
#查看索引
SHOW INDEX FROM table_name;
#删除索引
DROP INDEX index_name ON table_name;

#练习：
#1.name字段为姓名字段，该字段的值可能会重复，为该字段创建索引
create index idx_user_name on tb_user(name);
#2.phone手机号字段的值，是非空且唯一的，为该字段创建唯一索引
create unique index idx_user_phone on tb_user(phone);
#3.为profession、age、status创建联合索引
create index idx_user_pro_age_sta on tb_user(profession, age, status);
#4.为email创建合适的索引来体生查询效率
create index idx_user_email on tb_user(email);
#5.删除email的索引
drop index idx_email on tb_email;
</code></pre>
<h2 id="sql性能分析">SQL性能分析</h2>
<h3 id="sql执行频率">sql执行频率</h3>
<p>MySQL客户端连接成功后,通过<code>show [session|global] status</code>命令可以提供服务器状态信息。通过如下指令,可以查看当前数据库的<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、 <code>SELECT</code>的访问频次:</p>
<pre><code class="language-sql">show global status like 'Com_______';
</code></pre>
<h3 id="慢查询日志">慢查询日志</h3>
<p>（当我们发现执行Select语句的频次比较高）<br>
慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息:</p>
<pre><code class="language-sql">#开启MySQL慢日志查询开关
slow_query_log=1
#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
</code></pre>
<p>通过查看（/usr/local/mysql/localhost-slow.log）文件判断需要优化的语句</p>
<h3 id="profile详情">profile详情</h3>
<p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作：<code>select @@hava_profiling;</code>，默认profiling是关闭的，可以通过set语句在session/global级别开启profiling：<code>set profiling = 1;</code>，通过<code>show profiles;</code>查看每一条语句的执行时长</p>
<h3 id="explain执行计划">explain执行计划</h3>
<p>explain可以查看SQL的执行计划、是否执行索引以及表的连接情况，语法：</p>
<pre><code class="language-sql">#直接在select语句之前加上关键字explain/desc
explain select * from table1;
</code></pre>
<p><img src="https://Yichongtian.github.io/post-images/1681645085268.png" alt="" loading="lazy"><br>
各字段含义：（重点优化<code>type</code>，然后是<code>possible_keys</code>、<code>key</code>、<code>key_len</code>）</p>
<ul>
<li><code>id</code><br>
select查询的序列号,表示查询中执行select子句或者是操作表的顺序(id相同,执行顺序从上到下; id不同,值越大,越先执行)。</li>
<li><code>select_type</code><br>
表示SELECT的类型，常见的取值有SIMPLE (简单表，即不使用表连接或者子查询)、PRIMARY (主查询,即外层的查询)、UNION (UNION中的第二个或者后面的查询语句)、SUBQUERY (SELECT/WHERE之后包含了子查询)等。</li>
<li><code>type</code><br>
表示连接类型，性能由好到差的连接类型为NULL（不查任何表）、system、const（主键或唯一索引出现）、eq_ref、ref（使用非唯一索引出现）、range、index（用了索引，但是仍然要遍历索引）、all。</li>
<li><code>possible_key</code><br>
可能在这张表上用到的索引，一个或多个。</li>
<li><code>key</code><br>
实际使用的索引，如果为NULL,则没有使用索引。</li>
<li><code>key_len</code><br>
表示索引中使用的字节数，该值为索引字段最大可能长度,并非实际使用长度，在不损失精确性的前提下，长度越短越好。</li>
<li><code>rows</code><br>
MySQL认为必须要执行查询的行数，在innodb引擎的表中， 是一个估计值，可能并不总是准确的。</li>
<li><code>filtered</code><br>
表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</li>
</ul>
<h2 id="索引使用">索引使用</h2>
<ul>
<li><code>最左前缀法则</code><br>
如果索引了多列(联合索引) , 要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>
如果跳跃某一列, 索引将部分失效(后面的字段索引失效)。</li>
<li><code>范围查询</code><br>
联合索引中，出现范围查询(&gt;, &lt;)，范围查询右侧的列索引失效（所以尽量使用&gt;=和&lt;=来查询范围）</li>
<li><code>索引列运算</code><br>
尽量不要在索引列上进行运算操作，否则索引将失效</li>
<li><code>字符串不加引号</code><br>
字符串类型字段使用时，不加引号，索引将失效。</li>
<li><code>模糊查询</code><br>
如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</li>
<li><code>or连接的条件</code><br>
用or分割开的条件，如果or前的条件 中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
<li><code>数据分布影响</code><br>
如果MySQL评估使用索引比全表更慢，则不使用索引。</li>
<li><code>sql提示</code><br>
SQL提示，是优化数据库的一个重要手段， 简单来说,就是在SQL语句中加入-些人为的提示来达到优化操作的目的。<pre><code class="language-sql">#use index:建议mysql使用xx索引
explain select * from tb_user use index(idx_user_pro) where profession='软件工程';
#ignore index:忽略xx索引
explain select * from tb_user ignore index(idx_user_pro) where profession='软件工程';
#force index:强制mysql使用xx索引
explain select * from tb_user force index(idx_user_pro) where profession='软件工程';
</code></pre>
</li>
<li>覆盖索引<br>
尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中能全部找到，减少select*）<pre><code class="language-sql">#假设tb_user表建立了name字段的唯一索引，id为主键
#第一条sql在走完name索引（二级索引）之后还要根据拿到的id回表查询（聚集索引）
#第二条sql只需要走完name索引（二级索引）
select * from tb_user where name = 'Amy';
select id, name from tb_user where name = 'Amy';
</code></pre>
</li>
<li>前缀索引<br>
当字段类型为字符串(varchar, text等 )时，有时候需要索引很长的字符串,这会让索引变得很大，查询时,浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率。不重复的索引值占记录总数越多，效率越高<pre><code class="language-sql">#我要提取column列的前n个字符建立索引
create index idx_xxx on table_name(column(n));
#通过下面的方式来计算选择性
select count(distinct substring(email,1,5))/count(*) from tb_user;
</code></pre>
</li>
</ul>
<h2 id="索引设计原则">索引设计原则</h2>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高,使用索引的效率越高。</li>
<li>如果是字符串类型的字段,字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引,查询时，联合索引很多时候可以覆盖索引，节省存储空间,避免回表,提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大,会影响增删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
]]></content>
    </entry>
</feed>